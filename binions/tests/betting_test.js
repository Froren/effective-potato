// Generated by CoffeeScript 1.3.3
(function() {
  var Game, NoLimit, Player, assert, kPlayerStartingChips;

  assert = require('assert');

  NoLimit = require('../betting/no_limit')(10, 20);

  Player = require('../player').Player;

  Game = require('../game').Game;

  kPlayerStartingChips = 1000;

  describe("General betting expectations", function() {
    beforeEach(function() {
      var callsAll, n, _i;
      this.players = [];
      callsAll = {
        update: function(game) {
          if (game.state !== 'complete') {
            if (game.self.wagered < game.minToCall) {
              return game.minToCall - game.self.wagered;
            } else {
              return 0;
            }
          }
        }
      };
      for (n = _i = 0; _i <= 3; n = ++_i) {
        this.players.push(new Player(callsAll, kPlayerStartingChips, n));
      }
      this.state = 'flop';
      return this.noLimit = new NoLimit(this.players, this.state);
    });
    it("should calculate the correct minimum raise and call amounts at the start of a round", function() {
      var betOptions;
      betOptions = this.noLimit.analyze();
      assert.equal(10, betOptions['raise']);
      return assert.equal(0, betOptions['call']);
    });
    it("should allow a check", function() {
      var betAction, betOptions;
      betOptions = this.noLimit.analyze();
      this.noLimit.bet(0, 0, null);
      betAction = this.players[0].actions(this.state)[0];
      return assert(betAction['type'] === 'check');
    });
    it("should allow a player to raise", function() {
      var actingPlayer, betAction, betOptions, raiseAmount;
      betOptions = this.noLimit.analyze();
      actingPlayer = this.noLimit.nextToAct;
      raiseAmount = betOptions['call'] + betOptions['raise'];
      this.noLimit.bet(raiseAmount, 0, null);
      betAction = this.players[0].actions(this.state)[0];
      assert(betAction['type'] === 'raise');
      assert(betAction['bet'] === raiseAmount);
      return assert(this.noLimit.options()['call'] === raiseAmount);
    });
    it("should allow a player to go all-in", function() {
      var allInBet, betAction;
      this.noLimit.analyze();
      allInBet = this.players[0].chips;
      this.noLimit.bet(allInBet, 0, null);
      betAction = this.players[0].actions(this.state)[0];
      assert(betAction['type'] === 'allIn');
      return assert(betAction['bet'] === allInBet);
    });
    it("should allow a player to raise all-in", function() {
      var betAction;
      this.noLimit.analyze();
      this.noLimit.bet(this.noLimit.options()['call'] + this.noLimit.options()['raise'], 0, null);
      this.noLimit.bet(this.noLimit.options()['call'] + this.noLimit.options()['raise'], 1, null);
      this.noLimit.bet(kPlayerStartingChips, 2, null);
      betAction = this.players[2].actions(this.state)[0];
      assert(betAction['type'] === 'allIn');
      return assert(betAction['bet'] === kPlayerStartingChips);
    });
    it("should not allow a player to bet more chips than they have", function() {
      var betAction;
      this.noLimit.analyze();
      this.noLimit.bet(kPlayerStartingChips * 2, 0, null);
      betAction = this.players[0].actions(this.state)[0];
      assert(betAction['type'] === 'allIn');
      return assert(betAction['bet'] === kPlayerStartingChips);
    });
    it("should allow a player to fold", function() {
      var betAction, betOptions, raiseAmount;
      betOptions = this.noLimit.analyze();
      raiseAmount = betOptions['call'] + betOptions['raise'];
      this.noLimit.bet(raiseAmount, 0, null);
      this.noLimit.bet(0, 1, null);
      betAction = this.players[1].actions(this.state)[0];
      return assert(betAction['type'] === 'fold');
    });
    it("should allow a re-raise", function() {
      var betAction, betOptions, raiseAmount, reRaiseAmount;
      betOptions = this.noLimit.analyze();
      raiseAmount = betOptions['call'] + betOptions['raise'];
      this.noLimit.bet(raiseAmount, 0, null);
      reRaiseAmount = this.noLimit.options()['call'] + this.noLimit.options()['raise'];
      assert(reRaiseAmount > raiseAmount);
      this.noLimit.bet(reRaiseAmount, 1, null);
      betAction = this.players[1].actions(this.state)[0];
      return assert(betAction['type'] === 'raise');
    });
    it("should prevent a player from calling less than the call amount", function() {
      var actingPlayer, betAction, betOptions, raiseAmount;
      betOptions = this.noLimit.analyze();
      actingPlayer = this.noLimit.nextToAct;
      raiseAmount = betOptions['call'] + betOptions['raise'];
      this.noLimit.bet(raiseAmount, null, null);
      this.noLimit.bet(this.noLimit.options()['call'] - 1, null, null);
      betAction = this.players[1].actions(this.state)[0];
      return assert(betAction['type'] === 'fold');
    });
    return it("should prevent a player from raising less than the minimum amount", function() {
      var actingPlayer, betOptions;
      betOptions = this.noLimit.analyze();
      actingPlayer = this.noLimit.nextToAct;
      this.noLimit.bet(betOptions['call'] + betOptions['raise'] - 1, 0, null);
      return assert((this.players[0].actions(this.state)[0])['type'] === 'check');
    });
  });

}).call(this);
