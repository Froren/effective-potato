// Generated by CoffeeScript 1.3.3
(function() {
  var BLIND, Card, Game, MINIMUM, NoLimit, Player, assert, callsAll, folder, raisesAlways, raisesOnceEachRound, util;

  assert = require('assert');

  util = require('util');

  Game = require('../game').Game;

  Card = require('../../hoyle').Card;

  Player = require('../player').Player;

  NoLimit = require('../betting/no_limit');

  BLIND = 10;

  MINIMUM = 20;

  callsAll = {
    update: function(game) {
      if (game.state !== 'complete') {
        return game.betting.call;
      }
    }
  };

  raisesOnceEachRound = {
    update: function(game) {
      if (game.state !== 'complete') {
        if (game.state !== this.lastState) {
          this.lastState = game.state;
          return game.betting.raise;
        }
        return game.betting.call;
      }
    }
  };

  raisesAlways = {
    update: function(game) {
      if (game.state !== 'complete') {
        return game.betting.raise;
      }
    }
  };

  folder = {
    update: function(game) {
      return 0;
    }
  };

  describe("Basic game", function() {
    beforeEach(function() {
      var chips, n, _i, _results;
      this.noLimit = new NoLimit(BLIND, MINIMUM);
      this.players = [];
      chips = 1000;
      _results = [];
      for (n = _i = 0; _i <= 6; n = ++_i) {
        _results.push(this.players.push(new Player(callsAll, chips, n)));
      }
      return _results;
    });
    it("should play the game to completion", function(done) {
      var game;
      game = new Game(this.players, this.noLimit);
      game.on('complete', function() {
        assert.ok(game.winners.length > 0);
        return done();
      });
      game.on('roundComplete', function(state) {
        if (game.deal()) {
          return game.takeBets();
        } else {
          return game.settle();
        }
      });
      game.deck.on('shuffled', function() {
        game.deal();
        return game.takeBets();
      });
      return game.deck.shuffle();
    });
    it("should play the game to completion with run()", function(done) {
      var game;
      game = new Game(this.players, this.noLimit);
      game.run();
      return game.on('complete', function() {
        assert.ok(game.winners.length > 0);
        return done();
      });
    });
    it("should give the big blind an option", function(done) {
      var blindPlayers, game;
      blindPlayers = [];
      blindPlayers.push(new Player(callsAll, 1000, 0));
      blindPlayers.push(new Player(raisesOnceEachRound, 1000, 'dickblind'));
      [].splice.apply(this.players, [0, 2].concat(blindPlayers)), blindPlayers;
      game = new Game(this.players, this.noLimit);
      game.on('roundComplete', function(state) {
        var status;
        status = game.status();
        assert(this.players[1].wagered === MINIMUM);
        return done();
      });
      game.deck.on('shuffled', function() {
        game.deal();
        return game.takeBets();
      });
      return game.deck.shuffle();
    });
    it("should prevent a player from raising twice in a round", function(done) {
      var blindPlayers, game;
      blindPlayers = [];
      this.players.push(new Player(raisesAlways, 1000, 'raisebot'));
      game = new Game(this.players, this.noLimit);
      game.on('roundComplete', function(state) {
        var status;
        status = game.status();
        assert(this.players[this.players.length - 1].wagered === MINIMUM);
        return done();
      });
      game.deck.on('shuffled', function() {
        game.deal();
        return game.takeBets();
      });
      return game.deck.shuffle();
    });
    it("should take bets from all players after a raise when the next player in position has folded", function(done) {
      var game;
      this.players.push(new Player(folder, 1000, 'foldbot'));
      this.players.push(new Player(raisesAlways, 1000, 'raisebot'));
      this.players.push(new Player(folder, 1000, 'foldbot'));
      game = new Game(this.players, this.noLimit);
      game.on('roundComplete', function(state) {
        var player, _i, _len, _ref;
        _ref = this.players;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          player = _ref[_i];
          if (player.name === 'foldbot') {
            continue;
          }
          assert(player.wagered === this.players[0].wagered, "Wager for player " + player.name + " is not what was expected: " + player.wagered);
        }
        if (game.state === 'turn') {
          return done();
        } else {
          game.deal();
          return game.takeBets();
        }
      });
      game.deck.on('shuffled', function() {
        game.deal();
        return game.takeBets();
      });
      return game.deck.shuffle();
    });
    describe("settling the game", function() {
      return it("should payout the right amounts", function() {
        var game;
        game = new Game(this.players, this.noLimit);
        this.players[0].bet(5);
        this.players[1].bet(10);
        this.players[2].bet(0);
        game.distributeWinnings([this.players[1]]);
        assert.equal(this.players[2].payout, 0);
        assert.equal(this.players[2].chips, 1000);
        assert.equal(this.players[1].payout, 5);
        assert.equal(this.players[1].chips, 1005);
        assert.equal(this.players[0].payout, -5);
        return assert.equal(this.players[0].chips, 995);
      });
    });
    describe("splitting the pot", function() {
      it("should handle a tie", function() {
        var game, player, _i, _len, _ref;
        game = new Game(this.players, this.noLimit);
        game.community = ['As', 'Ah', '9c'].map(function(c) {
          return new Card(c);
        });
        this.players[0].cards = ['Ac', 'Kh'].map(function(c) {
          return new Card(c);
        });
        this.players[1].cards = ['Ad', 'Kh'].map(function(c) {
          return new Card(c);
        });
        _ref = this.players;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          player = _ref[_i];
          player.bet(50);
        }
        assert.equal(game.pot(), 350);
        game.settle();
        assert.equal(game.winners.length, 2);
        assert.equal(this.players[0].chips, 1125);
        assert.equal(this.players[1].chips, 1125);
        return assert.equal(this.players[2].chips, 950);
      });
      return it("should handle the dreaded three way uneven split", function() {
        var game, player, _i, _len, _ref;
        game = new Game(this.players, this.noLimit);
        game.community = ['As', '8c', '9c'].map(function(c) {
          return new Card(c);
        });
        this.players[0].cards = ['Ac', 'Kh'].map(function(c) {
          return new Card(c);
        });
        this.players[1].cards = ['Ad', 'Kd'].map(function(c) {
          return new Card(c);
        });
        this.players[2].cards = ['Ah', 'Ks'].map(function(c) {
          return new Card(c);
        });
        _ref = this.players;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          player = _ref[_i];
          player.bet(10);
        }
        assert.equal(game.pot(), 70);
        game.settle();
        assert.equal(game.winners.length, 3);
        assert.equal(this.players[3].chips, 990);
        assert.equal(this.players[0].chips, 1014);
        assert.equal(this.players[1].chips, 1013);
        return assert.equal(this.players[2].chips, 1013);
      });
    });
    describe("with side pots", function() {
      it("should handle side pots", function() {
        var game;
        game = new Game(this.players, this.noLimit);
        game.community = ['As', '8c', '9c'].map(function(c) {
          return new Card(c);
        });
        this.players[0].cards = ['Ac', '9d'].map(function(c) {
          return new Card(c);
        });
        this.players[0].bet(40);
        this.players[1].cards = ['Ad', '8d'].map(function(c) {
          return new Card(c);
        });
        this.players[1].bet(50);
        this.players[2].cards = ['Ah', '7s'].map(function(c) {
          return new Card(c);
        });
        this.players[2].bet(50);
        assert.equal(game.pot(), 140);
        game.settle();
        assert.equal(this.players[0].chips, 960 + (40 * 3));
        assert.equal(this.players[1].chips, 950 + (10 * 2));
        return assert.equal(this.players[2].chips, 950);
      });
      it("should handle side pots with a single winner(side pot loses)", function() {
        var game;
        game = new Game(this.players, this.noLimit);
        game.community = ['As', '8c', '9c'].map(function(c) {
          return new Card(c);
        });
        this.players[0].cards = ['Ac', '9d'].map(function(c) {
          return new Card(c);
        });
        this.players[0].bet(50);
        this.players[1].cards = ['Ad', '8d'].map(function(c) {
          return new Card(c);
        });
        this.players[1].bet(50);
        this.players[2].cards = ['Ah', '7s'].map(function(c) {
          return new Card(c);
        });
        this.players[2].bet(40);
        assert.equal(game.pot(), 140);
        game.settle();
        assert.equal(this.players[0].chips, 950 + (50 * 2) + 40);
        assert.equal(this.players[1].chips, 950);
        return assert.equal(this.players[2].chips, 960);
      });
      return it("should side pots, along with a split pot", function() {
        var game;
        game = new Game(this.players, this.noLimit);
        game.community = ['As', '8c', '9c'].map(function(c) {
          return new Card(c);
        });
        this.players[0].cards = ['Ac', '9d'].map(function(c) {
          return new Card(c);
        });
        this.players[0].bet(40);
        this.players[1].cards = ['Ad', '8d'].map(function(c) {
          return new Card(c);
        });
        this.players[1].bet(50);
        this.players[2].cards = ['Ah', '8s'].map(function(c) {
          return new Card(c);
        });
        this.players[2].bet(50);
        assert.equal(game.pot(), 140);
        game.settle();
        assert.equal(this.players[0].chips, 960 + (40 * 3));
        assert.equal(this.players[1].chips, 950 + 10);
        return assert.equal(this.players[2].chips, 950 + 10);
      });
    });
    describe("telling players what they won", function() {
      return it("should call payout", function(done) {
        var game, n, players, _i;
        players = [];
        for (n = _i = 0; _i <= 2; n = ++_i) {
          players.push(new Player({
            update: (function() {
              return 0;
            })
          }, 100, n));
        }
        players.push(new Player({
          update: function(game) {
            if (game.state === 'complete') {
              assert.ok;
              return done();
            } else {
              return 0;
            }
          }
        }, 100, 3));
        game = new Game(players, this.noLimit);
        return game.settle();
      });
    });
    return describe("with broke players", function() {
      it("should safely eject them", function() {
        var game, n, players, _i, _j;
        players = [];
        for (n = _i = 0; _i <= 2; n = ++_i) {
          players.push(new Player({}, 100, n));
        }
        for (n = _j = 0; _j <= 2; n = ++_j) {
          players.push(new Player({}, 0, n));
        }
        game = new Game(players, this.noLimit);
        return assert.equal(game.players.length, 3);
      });
      return it("should refuse to play games with less than two moneyed players", function() {
        var players, test;
        players = [new Player({}, 100), new Player({}, 0)];
        test = function() {
          return new Game(players, this.noLimit);
        };
        return assert.throws(test, /Not enough players/);
      });
    });
  });

}).call(this);
